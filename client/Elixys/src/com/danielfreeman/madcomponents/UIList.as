/** * <p>Original Author: Daniel Freeman</p> * * <p>Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions:</p> * * <p>The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software.</p> * * <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE.</p> * * <p>Licensed under The MIT License</p> * <p>Redistributions of files must retain the above copyright notice.</p> */package com.danielfreeman.madcomponents {	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.GradientType;	import flash.display.InteractiveObject;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.FocusEvent;	import flash.events.MouseEvent;	import flash.events.TextEvent;	import flash.events.TimerEvent;	import flash.geom.Rectangle;	import flash.text.TextFormat;/** * A list row was clicked.  This is a bubbling event. */	[Event( name="clicked", type="flash.events.Event" )]	/** * The Pull-Down-To-Refresh header was activated */	[Event( name="pullRefresh", type="flash.events.Event" )]	/** *  MadComponents List * <pre> * &lt;list *    id = "IDENTIFIER" *    colour = "#rrggbb" *    background = "#rrggbb, #rrggbb, ..." *    visible = "true|false" *    gapV = "NUMBER" *    gapH = "NUMBER" *    border = "true|false" *    autoLayout = "true|false" *    lines = "i,j,k..." *    pullDownRefresh = "true|false" *    pullDownColour = "#rrggbb" *    sortBy = "IDENTIFIER" *    sortMode = "MODE" *    index = "INTEGER" *    mask = "true|false" *    alignV = "scroll|no scroll" * /&gt; * </pre> */	public class UIList extends UIScrollVertical {			public static const CLICKED:String = "clicked";		public static const REFRESH:String = "pullRefresh";		protected static const TOP:Number = 40;		protected static const PULL_THRESHOLD:Number = 70;		protected static const FORMAT:TextFormat = new TextFormat("Tahoma",18);		public static var HIGHLIGHT:uint = 0x9999FF;		public static var PULL_DOWN_TEXT:String = "pull down to refresh";		public static var REFRESH_TEXT:String = "refreshing...";							protected var _renderer:XML;		protected var _simple:Boolean;		protected var _count:int;		protected var _cellHeight:Number = -1;		protected var _pressedCell:int = -1;		protected var _highlight:Shape;		protected var _clickRow:Boolean = true;		protected var _cellTop:Number=Number.NEGATIVE_INFINITY;		protected var _cellLeft:Number=0;		protected var _colours:Vector.<uint>;		protected var _suffix:String = "";		protected var _font:String = "";		protected var _model:Model = null;		protected var _search:UISearch = null;		protected var _top:Number = 0;		protected var _rendererAttributes:Attributes;		protected var _field:String;		protected var _data:Array;		protected var _filteredData:Array = [];		protected var _sortBy:String = "";		protected var _sortMode:String = "";		protected var _row:UIForm;		protected var _lines:Boolean = false;		protected var _cell:*;		protected var _refresh:UIRefresh = null;		protected var _refreshState:Boolean = false;		protected var _showPressed:Boolean = false;		protected var _textAlign:String;		public function UIList(screen:Sprite, xml:XML, attributes:Attributes) {			_colours = attributes.backgroundColours;			super(screen, xml, attributes);			_renderer = renderer(xml);			_simple = _renderer.toXMLString() == "";			if (!_simple) {				_rendererAttributes = attributes.copy();				_rendererAttributes.parse(xml);				_rendererAttributes.x = _rendererAttributes.y = 0;				_rendererAttributes.width-=2*_rendererAttributes.paddingH;				_rendererAttributes.height-=2*_rendererAttributes.paddingV;			}			if (xml.@lines.length()>0 && xml.@lines[0].toString()!="false") {				_lines=true;			}			if (xml.font.length()>0) {				_font = xml.font[0].toXMLString();			}			if (xml.search.length()>0) {				var searchAttributes:Attributes = attributes.copy(xml.search[0]);				searchAttributes.x = searchAttributes.y = 0;				_search = new UISearch(_slider,xml.search[0],searchAttributes);				if (xml.search[0].@id.length()>0)					_search.name = xml.search[0].@id[0];				_top = _search.height;				if (xml.search[0].@field.length()>0) {					_field=xml.search[0].@field[0];					_search.addEventListener(TextEvent.TEXT_INPUT, searchHandler);				}			}			if (xml.@pullDownRefresh.length()>0 && xml.@pullDownRefresh[0]!="false") {				_refresh = new UIRefresh(_slider, 0, -TOP/2, xml.@pullDownColour.length()>0 ? UI.toColourValue(xml.@pullDownColour[0]) : 0x333333, PULL_DOWN_TEXT);			}			if (xml.@sortBy.length()>0) {				_sortBy = xml.@sortBy[0];			}			if (xml.@sortMode.length()>0) {				_sortMode = xml.@sortMode[0];			}			if (xml.data.length()>0) {				xmlData = xml.data[0];			}			if (xml.model.length()>0) {				_model = new Model(this, xml.model[0]);			}			buttonMode = useHandCursor = true;			if (xml.@index.length()>0)				index = parseInt(xml.@index);		}		/** *  Scroll to index */		public function set index(value:int):void {			_pressedCell = value;			if (_slider.y + _cellHeight * value < MAXIMUM_DY/2) {				_endSlider = _cellHeight * value - _offset;				_moveTimer.start();							}			else {				_slider.y = - _cellHeight * value + _offset;			}			sliderMoved();		}				override protected function doLayoutHandler(event:Event):void {			doLayout();			event.stopPropagation();		}		/** *  Extract renderer XML from XML */		protected function renderer(xml:XML):XML {			var children:XMLList = xml.children();			if (children.length()==0)				return XML("");			else if (xml.data.length()==0 && xml.font.length()==0 && xml.model.length()==0 && xml.search.length()==0)				return children[0];						for each (var child:XML in children) {				if (child.localName()!="data" && child.localName()!="font" && child.localName()!="model" && child.localName()!="search") {					return child;				}			}			return XML("");		}		/** *  If set to true, the click highlight remains */		public function set showPressed(value:Boolean):void {			_showPressed = value;		}		/** *  Clears the click highlight. ( Useful if showPressed=true ) */		public function clearPressed():void {			_highlight.graphics.clear();		}		/** *  Set XML data */		public function set xmlData(value:XML):void {			var result:Array = [];			var children:XMLList = value.children();			for each (var child:XML in children)				if (child.nodeKind()!="text")				{					var item:Object = new Object();					var attributes:XMLList = child.attributes();					if (attributes.length()==0) {						item = {label:child.localName()};					}					else {						for (var i:int=0; i<attributes.length(); i++) {							  item[attributes[i].name().toString()] = attributes[i].toString();						}					}					result.push(item);				}			data = result;		}		/** *  Draw background */		override protected function drawBackground():void {			graphics.clear();			if (_colours && _colours.length > 0) {				graphics.beginFill(_colours[0]);			}			else {				graphics.beginFill(0,0);			}			graphics.drawRect(0, 0, _attributes.width, _attributes.height);		}		/** *  Rearrange the layout to new screen dimensions */			override public function layout(attributes:Attributes):void {			var last:Number = _top + _attributes.paddingV;			_width = attributes.width;			_height = attributes.height;			if (_search)				_search.fixwidth = attributes.width;			_attributes = attributes;			drawBackground();			initDraw();			if (_simple) {				for (var i:int = 0; i<_slider.numChildren; i++) {					var label:* = _slider.getChildAt(i);					if (label is UILabel) {						UILabel(label).fixwidth = _attributes.width-2*_attributes.paddingH;						label.multiline = label.wordWrap = false;					}				}			}			else {				_rendererAttributes.width=attributes.width - 2*attributes.paddingH;				_rendererAttributes.height=attributes.width - 2*attributes.paddingH;				if (_filteredData)					for (var l:int=0;l<_filteredData.length;l++) {						var cell:* = _slider.getChildByName("label_"+l.toString());						if (cell && cell is UIForm) {							UIForm(cell).layout(_rendererAttributes);							if (_autoLayout) {								cell.y = last;								last += cell.height + _attributes.paddingV;								drawCell(last, l);								last += _attributes.paddingV;							}						}					}			}			if (scrollRect)				scrollRect = new Rectangle(0,0,attributes.width,attributes.height);			if (!_autoLayout || _simple)				redrawCells();			calculateMaximumSlide();		}		/** *  Refresh layout */			override public function doLayout():void {				layout(_attributes);				adjustMaximumSlide();		}		/** *  Redraw cell chrome */			protected function redrawCells():void {			initDraw();			if (!_autoLayout) {				for (var l:int = 0; l < _filteredData.length; l++) {					drawCell(_cellHeight*(l+1) + _top, l);				}			}		}		/** *  Set up the scrolling part of the list */			override protected function createSlider(xml:XML, attributes:Attributes):void {			addChild(_slider = new Sprite());			_slider.addChild(_highlight=new Shape());			_width = attributes.width;			_height = attributes.height;		}						protected function sortParameter(value:String):* {			if (value.indexOf(",")<0) {				return value;			}			else {				return value.split(",");			}		}		/** *  Assign array of objects data */			override public function set data(value:Object):void {			_data = value as Array;			if (_sortBy!="" && _data) {				_data.sortOn(sortParameter(_sortBy),sortParameter(_sortMode));			}			filteredData = value as Array;		}		/** *  Set filtered data ( a sub-set of full data ). */			public function set filteredData(value:Array):void {			_filteredData = value;			data0 = value;		}		/** *  Set list data */			protected function set data0(value:Array):void {			if (_refresh)				_refresh.changeState(PULL_DOWN_TEXT, false);			clearCells();			initDraw();			if (_simple)				simpleRenderers(value, _cellTop + 2 * _attributes.paddingV);			else				customRenderers(value, _cellTop + _attributes.paddingV);			if (_autoLayout)				doLayout();			calculateMaximumSlide();		}		/** *  Calculate maximum slide */			protected function calculateMaximumSlide():void {			_scrollerHeight = _slider.height - (_refresh ? TOP : 0);			_maximumSlide = _scrollerHeight - _height;			if (_maximumSlide < 0)				_maximumSlide = 0;			if (_cellHeight<0 || _autoLayout)				_cellHeight = (_slider.height - _top - (_refresh ? TOP : 0)) / _count;		}		/** *  Data */			public function get data():Object {			return _data;		}		/** *  Filtered data */			public function get filteredData():Array {			return _filteredData;		}		/** *  Filter the data according to a search string */			public function filter(searchFor:String, field:String = "", caseSensitive:Boolean = false):void {			if (searchFor == "") {				filteredData = _data;			}			else {				if (field == "")					field = _field;				var result:Array = [];				for each (var record:Object in _data) {					var item:String = record[field];					if (!caseSensitive)						item = item.toLowerCase();					if (item.indexOf(searchFor) >= 0)						result.push(record);				}				filteredData = result;			}		}		/** *  Create list with simple default label rows */			protected function simpleRenderers(value:Array, position:Number = -1):void {			if (position < 0)				position = 2 * _attributes.paddingV;			_count = 0;			_textAlign = _attributes.textAlign;			for each (var record:* in value) {				var label:UILabel = labelCell(record, position);				position += label.height + 2 * _attributes.paddingV;				drawCell(position, _count);				position += 2 * _attributes.paddingV;				_cellHeight = 4 * _attributes.paddingV + label.height;				_count++;			}		}		/** *  Create a simple list label row */			protected function labelCell(record:*, position:Number):UILabel {			var labelText:String = record is String ? record : record.label;			var label:UILabel = newLabel();//_attributes.x + 			label.y = position;			label.name = "label_"+_count.toString()+_suffix;			if (XML("<t>"+labelText+"</t>").hasComplexContent()) {				var xmlString:String = XML(labelText).toXMLString();				label.htmlText = xmlString;			}			else {				if (_font!="") {					label.htmlText = _font.substr(0,_font.length-2)+ ">" + labelText + "</font>";				}				else {					label.text = labelText;				}			}						if (_textAlign != "") {				var format:TextFormat = new TextFormat();				format.align = _textAlign;				label.setTextFormat(format);			}						label.fixwidth = _attributes.width-2*_attributes.paddingH;			label.multiline = label.wordWrap = false;						return label;		}		/** *  Clear list */			protected function initDraw():void {			_slider.graphics.clear();			resizeRefresh();			_slider.graphics.beginFill(_colour);			_slider.graphics.drawRect(0, _top, _width, 1);			_cellTop = _top;		}		/** *  Resize list row chrome */			protected function resizeRefresh():void {			if (_refresh) {				_slider.graphics.beginFill(_colours.length>0 ? _colours[_colours.length-1] : 0xF9F9F9);				_slider.graphics.drawRect(0, -TOP, attributes.width, TOP);				_refresh.x = (attributes.width - _refresh.width) / 2;			}		}		/** *  Clear list */			protected function clearCells():void {			var i:int = _slider.numChildren;			while (--i>=(_search ? 2 : 1)+(_refresh ? 1 : 0)) {				_slider.removeChildAt(i);			}		}		/** *  Draw row chrome */			protected function drawCell(position:Number, count:int):void {			drawSimpleCell(position, count);		}		/** *  Draw row chrome */			protected function drawSimpleCell(position:Number, count:int):void {			position = Math.floor(position);			if (_colours.length > 1) {				_slider.graphics.beginFill(_colours[count % (_colours.length - 1) + 1]);				_slider.graphics.drawRect(0, _cellTop + 2, _width, position - _cellTop - 1);			}			_slider.graphics.beginFill(_colour);			_slider.graphics.drawRect(0, position, _width, 1);			drawLines(position);			_cellTop = position;		}		/** *  Draw lines within row */			protected function drawLines(position:Number):void {			if (_lines && _cell is UIForm) {				_slider.graphics.beginFill(_colours[0]);				var positions:Array = _cell.positions;				for (var i:int = 1; i<positions.length; i++) {					_slider.graphics.drawRect(_cell.x+positions[i] - _attributes.paddingH/2, _cellTop+1, 1, position - _cellTop);				}			}		}		/** *  Return DisplayObject of button pressed */		override protected function pressButton():DisplayObject {			_scrollBarLayer.graphics.clear();			_highlight.graphics.clear();			if (!_simple || _slider.mouseY<_top) {				doSearchHit();			}			if (!_pressButton && _clickRow) {				if (_autoLayout && !_simple && _slider.mouseY > _top) {					_pressedCell = autoLayoutPressedCell();					if (_pressedCell >= 0 && _pressedCell < _count) {						_highlight.graphics.beginFill(HIGHLIGHT);						_highlight.graphics.drawRect(0, _row.y - _attributes.paddingV +1, _width, _row.height + 2*_attributes.paddingV -1 ); //_attributes.x + 						activate();					}				}				else {					_pressedCell = Math.floor((_slider.mouseY - _top)/_cellHeight);					if (_pressedCell >= 0 && _pressedCell < _count) {						_highlight.graphics.beginFill(HIGHLIGHT);						_highlight.graphics.drawRect(0, _top + _pressedCell * _cellHeight +1, _width, _cellHeight -1); //_attributes.x + 						activate();					}				}			}			return _pressButton;		}		/** *  If autoLayout="true", which cell was clicked? */		protected function autoLayoutPressedCell():int {			var n:int = 0;			for (var l:int=0;l<_slider.numChildren - 1;l++) {				var row:* = _slider.getChildAt(l+1);								if (row && row is UIForm) {					_row = UIForm(row);					if (_row.y + _row.height + _attributes.paddingV > _slider.mouseY)						return n;					n++;				}			}			return -1;		}		/** *  Row has been clicked */		protected function activate():void {			_touchTimer.stop();			_dragTimer.stop();			_clickTimer.stop();			_clickTimer.reset();			_clickTimer.start();			dispatchEvent(new Event(CLICKED,true));			stage.removeEventListener(MouseEvent.MOUSE_UP,mouseUp);		}		/** *  Index of last row clicked */		public function get index():int {			return _pressedCell;		}		/** *  Data object for last row clicked */		public function get row():Object {			return (_pressedCell>=0) ? _filteredData[_pressedCell] : null;		}		/** *  Click up handler */		override protected function clickUp(event:TimerEvent):void {			if (!_simple) {				super.clickUp(event);			}			if (_clickRow && !_showPressed) {				_highlight.graphics.clear();			}			_scrollBarLayer.graphics.clear();		}		/** *  Create list with custom renderers */		protected function customRenderers(value:Array, position:Number = -1):void {			if (position < 0)				position = _attributes.paddingV;			_count = 0;			for each (var record:Object in value) {				customCell(record, position);				position += _cell.height + _attributes.paddingV;				drawCell(position, _count);				position += _attributes.paddingV;				_count++;			}		}		/** *  Instanciate a new list row */		protected function newRow():UIForm {			return new UI.FormClass(_slider, _renderer, _rendererAttributes, true);		}				/** *  Instanciate a new list label */		protected function newLabel():UILabel {			return new UILabel(_slider, _attributes.paddingH, 0, "", FORMAT);		}		/** *  Create and position a new list row */		protected function customCell(record:Object, position:Number):void {			if (!UI.isForm(_renderer.localName()))				_renderer = XML("<horizontal>" + _renderer.toXMLString() + "</horizontal>");			_cell = newRow();			_cell.x = _cellLeft +_rendererAttributes.paddingH;			_cell.y = position;			_cell.mouseChildren = false;			_cell.name = "label_"+_count.toString()+_suffix;						fillInValues(_cell, record);			_cellHeight = _cell.height + 2*_attributes.paddingV;		}		/** *  Assign data to custom renderer components */		protected function fillInValues(cell:UIForm, record:Object):void {			for (var id:String in record) {				var view:* = cell.findViewById(id);				if (view) {					var value:String = record[id];					try {						if (XML("<o>"+value+"</o>").hasComplexContent() && view is UILabel) {							view.htmlText = value;						}						else {							view.text = value;						}					}					catch (error:Error) {						view.text = value;					}				}			}		}		/** *  If true, rows are clickable */		public function set clickRow(value:Boolean):void {			_clickRow = value;		}		/** *  Model */		override public function get model():Model {			return _model;		}		/** *  Handle search field filter */		protected function searchHandler(event:Event):void {			filter(_search.text.toLowerCase());		}		/** *  Determine what has been clicked */		override protected function doSearchHit():void {			super.doSearchHit();			if (_pressButton is InteractiveObject && !InteractiveObject(_pressButton).mouseEnabled)				_pressButton = null;		}		/** *  Return component matching id within row matching row index */		override public function findViewById(id:String, row:int = -1, group:int = -1):DisplayObject {			if (_search && _search.name == id) {				return _search;			}			else if (_simple) {				return _slider.getChildByName(id+"_"+row.toString());			}			else if (row>=0) {				var container:IContainerUI = IContainerUI(_slider.getChildAt(row+1));				return container ? container.findViewById(id, row, group) : null;			}			else {				return null;			}		}		/** *  Mouse move handler */		override protected function mouseMove(event:TimerEvent):void {			if (_refresh && !_refreshState && _slider.y>PULL_THRESHOLD) {				_refresh.changeState(REFRESH_TEXT, true);				if (_model)					_model.refresh();				_refreshState = true;				dispatchEvent(new Event(REFRESH));			}			super.mouseMove(event);		}		/** *  Stop list movement */		override protected function stopMovement():void {			super.stopMovement();			_refreshState = false;		}						override public function destructor():void {			if (_search) {				_search.removeEventListener(TextEvent.TEXT_INPUT, searchHandler);				_search.destructor();			}		}	}}